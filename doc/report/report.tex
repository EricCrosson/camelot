\documentclass[12pt]{article}
%
%Margin - 1 inch on all sides
%
\usepackage[letterpaper]{geometry}
\geometry{top=1.0in, bottom=1.0in, left=1.0in, right=1.0in}

%
%Doublespacing
%
\usepackage{setspace}
\doublespacing
%
%Babel package for multiple language typesetting
%
%\usepackage[english,german]{babel}
%\usepackage[T1]{fontenc}
%\usepackage[latin1]{inputenc}
%
%Setting the font
%
\usepackage{times}
%
%Rotating tables (e.g. sideways when too long)
%
\usepackage{rotating}
%
%For multiple rows in tables
%
\usepackage{multirow}
%
%Line numbering in verse environment
%
\usepackage{lineno}

%
%Fancy-header package to modify header/page numbering (insert last name)
%
\usepackage{fancyhdr}
\usepackage{graphicx}
\graphicspath{ {../img/} }
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{TODO \thepage}
\lfoot{}
\cfoot{}
\rfoot{}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}
%To make sure we actually have header 0.5in away from top edge
%12pt is one-sixth of an inch. Subtract this from 0.5in to get headsep value
\setlength\headsep{0.333in}
%
%Works cited environment
%(to start, use \begin{workscited...}, each entry preceded by \bibent)
% - from Ryan Alcock's MLA style file
%
\newcommand{\bibent}{\noindent \hangindent 40pt}
\newenvironment{workscited}{\newpage \begin{center} Works Cited \end{center}}{\newpage }

%
%Begin document
%
\begin{document}
\begin{flushleft}
%%%%First page name, class, etc
Eric Crosson, William Mauldin, and Daniel Officewala \\
Professor Vijay Garg\\
EE 360P \\
\today \\

%%%%Title
\begin{center}
\emph{Dining Philosophers}
\end{center}

%%%%Changes paragraph indentation to 0.5in
\setlength{\parindent}{0.5in}
%%%%Begin body of paper here

\textbf{Introduction}
\newline
Dining Philosopher is a widely used Letâ€™s say there are some N philosophers sitting around a table. Philosophers only eat and think. At the center of the table is a plate of spaghetti and N forks (same as the number of philosophers, one between each philosopher sitting at the table). If a philosopher wants to eat, he/she must get two forks (the ones on either side of the philosopher). If one of the forks is currently in use by another philosopher, then he/she must wait until both forks are available before eating. Once a philosopher is done eating, he/she releases the forks used for another philosopher to acquire it and start their meal.

\textbf{The Algorithm}
\newline
There is an initial array of N booleans (call it bool forks[N]), representing the forks on the table (true if the fork is available, false if not). If a process with PID wants to eat, he first checks if (forks[pid] == true). If true, the fork changes to false to indicate that the philosopher acquired the fork. However, it forks[pid] ==  false, the philosopher must wait until that fork becomes free. Then the philosopher must get his/her second fork, namely forks[(pid + 1) % N], repeating the same check as above.
In every group, there is a philosopher kinder than the rest. This philosopher behaves almost identical to his fellow philosophers except in one aspect: when he/she attempts to get this second fork, if the attempt fails, he/she releases the first fork instead of waiting for the second fork to become available. Then the philosopher goes back to thinking and tries again later.

\textbf{Evaluation}
\newline
A common problem with that pops up in any discussion of Dining Philosopher problem/algorithm is the possibility of deadlock, when all the philosophers pick up a fork and forever waits on someone to finish with their other fork (but everyone is waiting so...). The special philosopher circumvents the issue by giving up both fork if he/she cannot get both forks, which allows another philosopher to finish eating and surrender its fork for another philosopher to start eating. Spins demonstrates that this technique does in fact solve deadlock.
Unfortunately, this algorithm does not prevent starvation. The philosopher that share the second fork with this special philosopher could in theory manage to get the fork before the special philosopher, and thus forever make that special philosopher surrender his/her forks.

TODO
\section{Introduction}
Here we should mention something about how due to the semantics of Promela, channels are FIFO
\section{Project Description}
\subsection{Chandy and Lamport's Global Snapshot Algorithm}

A global state is a set of local states that occur simultaneously.

The Chandy-Lamport algorithm defines a method to take a global snapshot of a distributed system, which has proven to be a challenge due to the absence of shared memory and a shared clock [\textbf{TODO}: http://www.cfdvs.iitb.ac.in/projects/CourseProjs/Y2K2/naren.ps]. In this algorithm, the global snapshot is determined by collecting all process states (messages sent and received by a given process) and channel states (messages in transit). Processes record their own states and use markers (special types of messages) to deduce the channel states. All channels are assumed to be unidirectional and FIFO.

For any given process, for each of its outbound channels, the process sends a marker after recording its state and before sending any subsequent messages. When a marker is received by another process, if such a process has not recorded its own state, it does so with its current status, and designates the channel as empty (since this must have been the case for the message have been received prior to the local snapshot). Otherwise, the receiving process records its channel state as the sequence of messages it received after recording its state and prior to the reception of the marker. This recorded sequence of messages reflects the channel state.

The purpose of model-checking the Chandy-Lamport algorithm is to verify that each state recorded is consistent, i.e. $$\forall i,j:G[i]||G[j],$$ where $G$ is a set of local states with exactly one local state from each process, $G[i]$ is the local state from process $P_i$, and $G[j]$ is the local state for process $P_j$ [\textbf{TODO}: citation from Garg book].

\section{Performance Results}
\subsection{Chandy and Lamport's Global Snapshot Algorithm}
To verify Chandy and Lamport's Global Snapshot Algorithm, we used the Promela model created originally by Mordecai Ben-Ari in Principles of the Spin Model Checker [INSERT REFERENCE]. Since a global state is considered consistent if any two local states of two separate processes are effectively concurrent during that global state, the model simply consists of one \texttt{Sender} and one \texttt{Receiver} proctype. All that is needed to verify a consistent state is to show that the local states of the \texttt{Sender} and the \texttt{Receiver} fit the definition of consistent, i.e. that all messages sent prior to the marker are received, and that any messages sent after the marker are recorded as a part of the channel's state. These is checked by the two assert statements \texttt{assert (lastSent == messageAtMarker)} and \texttt{assert (messageAtRecord <= messageAtMarker)}. Although Ben-Ari suggested that having a channel size of 4 and a total message number of 6 would be sufficient in verifying the model, our build system allowed for us to input custom parameters if desired. The model as seen after being evaluated in iSpin is shown below.
[Spin Book, pages 198-200]
\section{Conclusions}

\end{flushleft}
\end{document}
\}


